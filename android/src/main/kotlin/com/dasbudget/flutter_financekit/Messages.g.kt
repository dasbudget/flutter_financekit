// Autogenerated from Pigeon (v14.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.dasbudget.flutter_financeKit

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  if (exception is FlutterError) {
    return listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    return listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Values that describe the kinds of data in the finance store. */
enum class ApiDataType(val raw: Int) {
  /** The value that describes financial data, such as account information. */
  FINANCIALDATA(0),
  /** The value that describes orders records, such as purchases. */
  ORDERS(1);

  companion object {
    fun ofRaw(raw: Int): ApiDataType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class ApiAuthorizationStatus(val raw: Int) {
  /** A person authorized the app to use FinanceKit services. */
  AUTHORIZED(0),
  /** A person denied the use of FinanceKit services for the app */
  DENIED(1),
  /** A person has not chosen whether the app can use FinanceKit services. */
  NOTDETERMINED(2);

  companion object {
    fun ofRaw(raw: Int): ApiAuthorizationStatus? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Values that describe kinds of transactions. */
enum class ApiTransactionType(val raw: Int) {
  /** A credit or debit adjustment transaction. */
  ADJUSTMENT(0),
  /** An ATM transaction. */
  ATM(1),
  /** A bill payment, usually carried out through an eBill or eCheck system. */
  BILLPAYMENT(2),
  /** A check payment. */
  CHECK(3),
  /** A deposit of money by a payer into a payee’s bank account. */
  DEPOSIT(4),
  /** A payment to a third party on agreed dates, typically in order to pay bills. */
  DIRECTDEBIT(5),
  /** A deposit of money by a payer directly into a payee’s bank account. */
  DIRECTDEPOSIT(6),
  /** A distribution of a company’s earnings to its shareholders. */
  DIVIDEND(7),
  /** A fee or charge levied by the account provider. */
  FEE(8),
  /** A credit or debit due to interest earned or incurred. */
  INTEREST(9),
  /** A loan drawdown or repayment. */
  LOAN(10),
  /** A Point of Sales transaction. */
  POINTOFSALE(11),
  /** A refund. */
  REFUND(12),
  /** A regular payment of a fixed amount that’s paid on a specified date. */
  STANDINGORDER(13),
  /** A transfer between accounts. */
  TRANSFER(14),
  /** The transaction’s category doesn’t map to a known value. */
  UNKNOWN(15),
  /** An automatic or recurring withdrawal of funds by another party. */
  WITHDRAWAL(16);

  companion object {
    fun ofRaw(raw: Int): ApiTransactionType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Values that describe the status of a transaction. */
enum class ApiTransactionStatus(val raw: Int) {
  /** The transaction is in an authorized state. */
  AUTHORIZED(0),
  /** The transaction is in a booked state. */
  BOOKED(1),
  /** A memo that provides information about the transaction. */
  MEMO(2),
  /** The transaction is in a pending state. */
  PENDING(3),
  /** The transaction is in a rejected state. */
  REJECTED(4);

  companion object {
    fun ofRaw(raw: Int): ApiTransactionStatus? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Values that the framework uses to describe transactions as credits or debits. */
enum class ApiCreditDebitIndicator(val raw: Int) {
  /** A value that indicates an amount which increases an asset or decreases a liability. */
  CREDIT(0),
  /** A value that indicates an amount which increases a liability or decreases an asset. */
  DEBIT(1);

  companion object {
    fun ofRaw(raw: Int): ApiCreditDebitIndicator? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class ApiAccountType(val raw: Int) {
  /** An asset account. */
  ASSET(0),
  /** A liability account. */
  LIABILITY(1);

  companion object {
    fun ofRaw(raw: Int): ApiAccountType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Values that describe the state of an account’s credit balance.
 *
 * It can contain an indication of funds immediately available to the customer,
 * fund with all booked transactions (this excludes pending transactions), or both.
 */
enum class ApiCurrentBalance(val raw: Int) {
  /** Only the available balance is present. */
  AVAILABLE(0),
  /** Both available and booked balances are present. */
  AVAILABLEANDBOOKED(1),
  /** Only the booked balance is present. */
  BOOKED(2);

  companion object {
    fun ofRaw(raw: Int): ApiCurrentBalance? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ApiPredicate (
  val ids: String? = null,
  val minAmount: Long? = null,
  val maxAmount: Long? = null,
  val minTime: Long? = null,
  val maxTime: Long? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ApiPredicate {
      val ids = list[0] as String?
      val minAmount = list[1].let { if (it is Int) it.toLong() else it as Long? }
      val maxAmount = list[2].let { if (it is Int) it.toLong() else it as Long? }
      val minTime = list[3].let { if (it is Int) it.toLong() else it as Long? }
      val maxTime = list[4].let { if (it is Int) it.toLong() else it as Long? }
      return ApiPredicate(ids, minAmount, maxAmount, minTime, maxTime)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      ids,
      minAmount,
      maxAmount,
      minTime,
      maxTime,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ApiSortDescriptor (
  val id: Boolean? = null,
  val date: Boolean? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ApiSortDescriptor {
      val id = list[0] as Boolean?
      val date = list[1] as Boolean?
      return ApiSortDescriptor(id, date)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      id,
      date,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ApiQueryParams (
  val sortDescriptors: List<ApiSortDescriptor?>? = null,
  val predicate: ApiPredicate? = null,
  val limit: Long? = null,
  val offset: Long? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ApiQueryParams {
      val sortDescriptors = list[0] as List<ApiSortDescriptor?>?
      val predicate: ApiPredicate? = (list[1] as List<Any?>?)?.let {
        ApiPredicate.fromList(it)
      }
      val limit = list[2].let { if (it is Int) it.toLong() else it as Long? }
      val offset = list[3].let { if (it is Int) it.toLong() else it as Long? }
      return ApiQueryParams(sortDescriptors, predicate, limit, offset)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      sortDescriptors,
      predicate?.toList(),
      limit,
      offset,
    )
  }
}

/**
 * A structure that describes a monetary amount and its currency.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ApiCurrencyAmount (
  /** The numeric value of the amount. */
  val amount: String,
  /** The currency of the amount. */
  val currencyCode: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ApiCurrencyAmount {
      val amount = list[0] as String
      val currencyCode = list[1] as String
      return ApiCurrencyAmount(amount, currencyCode)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      amount,
      currencyCode,
    )
  }
}

/**
 * A structure that represents a transaction relating to a specific financial account.
 * This can include transactions such as a deposit to or a withdrawn from bank account, a credit card transaction.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ApiTransaction (
  /** A unique internal ID. */
  val id: String,
  /** The account ID the transaction belongs to. */
  val accountID: String,
  /** An indicator that describes if the transaction is a credit or a debit. */
  val creditDebitIndicator: ApiCreditDebitIndicator,
  /** The total amount of the transaction, if it was carried out in a foreign currency. */
  val foreignCurrencyAmount: ApiCurrencyAmount? = null,
  /** The currency exchange rate, if the transaction was carried out in a foreign currency. */
  val foreignCurrencyExchangeRate: String? = null,
  /** The ISO 18245 category code for the transaction. */
  val merchantCategoryCode: Long? = null,
  /** The name of the merchant, if present. */
  val merchantName: String? = null,
  /** The unmodified description of the transaction. */
  val originalTransactionDescription: String,
  /** The date and time that the transaction was posted to the account. */
  val postedDate: Long? = null,
  /** The status of the transaction, if available. */
  val status: ApiTransactionStatus,
  /** The total amount of the transaction. */
  val transactionAmount: ApiCurrencyAmount,
  /** The time the transaction took place, if available. */
  val transactionDate: Long,
  /** A description of the transaction. */
  val transactionDescription: String,
  /** The type of the transaction. */
  val transactionType: ApiTransactionType

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ApiTransaction {
      val id = list[0] as String
      val accountID = list[1] as String
      val creditDebitIndicator = ApiCreditDebitIndicator.ofRaw(list[2] as Int)!!
      val foreignCurrencyAmount: ApiCurrencyAmount? = (list[3] as List<Any?>?)?.let {
        ApiCurrencyAmount.fromList(it)
      }
      val foreignCurrencyExchangeRate = list[4] as String?
      val merchantCategoryCode = list[5].let { if (it is Int) it.toLong() else it as Long? }
      val merchantName = list[6] as String?
      val originalTransactionDescription = list[7] as String
      val postedDate = list[8].let { if (it is Int) it.toLong() else it as Long? }
      val status = ApiTransactionStatus.ofRaw(list[9] as Int)!!
      val transactionAmount = ApiCurrencyAmount.fromList(list[10] as List<Any?>)
      val transactionDate = list[11].let { if (it is Int) it.toLong() else it as Long }
      val transactionDescription = list[12] as String
      val transactionType = ApiTransactionType.ofRaw(list[13] as Int)!!
      return ApiTransaction(id, accountID, creditDebitIndicator, foreignCurrencyAmount, foreignCurrencyExchangeRate, merchantCategoryCode, merchantName, originalTransactionDescription, postedDate, status, transactionAmount, transactionDate, transactionDescription, transactionType)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      id,
      accountID,
      creditDebitIndicator.raw,
      foreignCurrencyAmount?.toList(),
      foreignCurrencyExchangeRate,
      merchantCategoryCode,
      merchantName,
      originalTransactionDescription,
      postedDate,
      status.raw,
      transactionAmount.toList(),
      transactionDate,
      transactionDescription,
      transactionType.raw,
    )
  }
}

/**
 * A structure that describes the credit information associated with an account.
 * Credit information includes credit limits, payment dates, and minimum payment dates and amounts for current and upcoming payments.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ApiAccountCreditInformation (
  /** The credit limit of the account. */
  val creditLimit: ApiCurrencyAmount? = null,
  /** Minimum amount of the next non-overdue payment. */
  val minimumNextPaymentAmount: ApiCurrencyAmount? = null,
  /** Date of the next payment. */
  val nextPaymentDueDate: Long? = null,
  /** The amount by which the account is overdue for the current period. */
  val overduePaymentAmount: ApiCurrencyAmount? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ApiAccountCreditInformation {
      val creditLimit: ApiCurrencyAmount? = (list[0] as List<Any?>?)?.let {
        ApiCurrencyAmount.fromList(it)
      }
      val minimumNextPaymentAmount: ApiCurrencyAmount? = (list[1] as List<Any?>?)?.let {
        ApiCurrencyAmount.fromList(it)
      }
      val nextPaymentDueDate = list[2].let { if (it is Int) it.toLong() else it as Long? }
      val overduePaymentAmount: ApiCurrencyAmount? = (list[3] as List<Any?>?)?.let {
        ApiCurrencyAmount.fromList(it)
      }
      return ApiAccountCreditInformation(creditLimit, minimumNextPaymentAmount, nextPaymentDueDate, overduePaymentAmount)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      creditLimit?.toList(),
      minimumNextPaymentAmount?.toList(),
      nextPaymentDueDate,
      overduePaymentAmount?.toList(),
    )
  }
}

/**
 * A structure that describes an account balance.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ApiBalance (
  /** The amount of the balance. */
  val amount: ApiCurrencyAmount,
  /** The date and time the system calculated the balance. */
  val asOfDate: Long,
  /** A value that indicates whether the balance is a credit or a debit balance. */
  val creditDebitIndicator: ApiCreditDebitIndicator

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ApiBalance {
      val amount = ApiCurrencyAmount.fromList(list[0] as List<Any?>)
      val asOfDate = list[1].let { if (it is Int) it.toLong() else it as Long }
      val creditDebitIndicator = ApiCreditDebitIndicator.ofRaw(list[2] as Int)!!
      return ApiBalance(amount, asOfDate, creditDebitIndicator)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      amount.toList(),
      asOfDate,
      creditDebitIndicator.raw,
    )
  }
}

/**
 * A structure that describes the financial balance of an account at a specific point in time.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ApiAccountBalance (
  /** The account ID the balance belongs to. */
  val accountID: String,
  /** The available balance, if present. */
  val available: ApiBalance? = null,
  /** The booked balance, if present. */
  val booked: ApiBalance? = null,
  /** The balance currency. */
  val currencyCode: String,
  /** The balance at a particular moment in time. */
  val currentBalance: ApiCurrentBalance,
  /** A unique account balance ID. */
  val id: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ApiAccountBalance {
      val accountID = list[0] as String
      val available: ApiBalance? = (list[1] as List<Any?>?)?.let {
        ApiBalance.fromList(it)
      }
      val booked: ApiBalance? = (list[2] as List<Any?>?)?.let {
        ApiBalance.fromList(it)
      }
      val currencyCode = list[3] as String
      val currentBalance = ApiCurrentBalance.ofRaw(list[4] as Int)!!
      val id = list[5] as String
      return ApiAccountBalance(accountID, available, booked, currencyCode, currentBalance, id)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      accountID,
      available?.toList(),
      booked?.toList(),
      currencyCode,
      currentBalance.raw,
      id,
    )
  }
}

/**
 * A structure that describes the characteristics of a liability account.
 * A liability account includes accounts such as credit cards.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ApiLiabilityAccount (
  /** A description of the account. */
  val accountDescription: String? = null,
  /** Information regarding credits to the account. */
  val creditInformation: ApiAccountCreditInformation,
  /** An ISO 4217 currency code that identifies the currency in which the account is held. */
  val currencyCode: String,
  /** The name for the account given by an individual. */
  val displayName: String,
  /** A unique account ID. */
  val id: String,
  /** The name of the institution that holds the account. */
  val institutionName: String,
  /** The date the account was opened, if known. */
  val openingDate: Long? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ApiLiabilityAccount {
      val accountDescription = list[0] as String?
      val creditInformation = ApiAccountCreditInformation.fromList(list[1] as List<Any?>)
      val currencyCode = list[2] as String
      val displayName = list[3] as String
      val id = list[4] as String
      val institutionName = list[5] as String
      val openingDate = list[6].let { if (it is Int) it.toLong() else it as Long? }
      return ApiLiabilityAccount(accountDescription, creditInformation, currencyCode, displayName, id, institutionName, openingDate)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      accountDescription,
      creditInformation.toList(),
      currencyCode,
      displayName,
      id,
      institutionName,
      openingDate,
    )
  }
}

/**
 * A structure that describes the characteristics of an asset account.
 * An asset account includes accounts such as a bank account or a savings account.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ApiAssetAccount (
  /** The description of the account. */
  val accountDescription: String? = null,
  /** ISO 4217 currency code that identifies the currency in which the account is held. */
  val currencyCode: String,
  /** The name for the account given by a person. */
  val displayName: String,
  /** A unique account identifier. */
  val id: String,
  /** The name of the institution that holds the account. */
  val institutionName: String,
  /** The date the account was opened, if known. */
  val openingDate: Long? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ApiAssetAccount {
      val accountDescription = list[0] as String?
      val currencyCode = list[1] as String
      val displayName = list[2] as String
      val id = list[3] as String
      val institutionName = list[4] as String
      val openingDate = list[5].let { if (it is Int) it.toLong() else it as Long? }
      return ApiAssetAccount(accountDescription, currencyCode, displayName, id, institutionName, openingDate)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      accountDescription,
      currencyCode,
      displayName,
      id,
      institutionName,
      openingDate,
    )
  }
}

/**
 * A structure that describes a financial account.
 * Accounts can include a variety of financial account types such as a bank account, a credit card, or a college fund.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ApiAccount (
  val type: ApiAccountType,
  /** A person’s description of this account. */
  val accountDescription: String? = null,
  /** The ISO 4217 currency code that identifies the currency that denominates the account. */
  val currencyCode: String,
  /** The name for this account that a person provided. */
  val displayName: String,
  /** The unique account ID for this account. */
  val id: String,
  /** The name of the institution that holds this account. */
  val institutionName: String,
  /** The date the account was opened, if known. */
  val openingDate: Long? = null,
  /** A liability account. */
  val liabilityAccount: ApiLiabilityAccount? = null,
  /** An asset account. */
  val assetAccount: ApiAssetAccount? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ApiAccount {
      val type = ApiAccountType.ofRaw(list[0] as Int)!!
      val accountDescription = list[1] as String?
      val currencyCode = list[2] as String
      val displayName = list[3] as String
      val id = list[4] as String
      val institutionName = list[5] as String
      val openingDate = list[6].let { if (it is Int) it.toLong() else it as Long? }
      val liabilityAccount: ApiLiabilityAccount? = (list[7] as List<Any?>?)?.let {
        ApiLiabilityAccount.fromList(it)
      }
      val assetAccount: ApiAssetAccount? = (list[8] as List<Any?>?)?.let {
        ApiAssetAccount.fromList(it)
      }
      return ApiAccount(type, accountDescription, currencyCode, displayName, id, institutionName, openingDate, liabilityAccount, assetAccount)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      type.raw,
      accountDescription,
      currencyCode,
      displayName,
      id,
      institutionName,
      openingDate,
      liabilityAccount?.toList(),
      assetAccount?.toList(),
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ApiHistoryToken (
  val test: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ApiHistoryToken {
      val test = list[0] as String
      return ApiHistoryToken(test)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      test,
    )
  }
}

/**
 * A structure that records changes to the finance store.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ApiChanges (
  /** An array of model objects identifiers that the framework deleted from the finance store. */
  val deleted: List<String?>,
  /** An array of model objects the framework inserted into the finance store. */
  val inserted: List<String?>,
  /** An updated history token. */
  val newToken: ApiHistoryToken,
  /** An array of model objects that the framework updated in the finance store. */
  val updated: List<String?>

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ApiChanges {
      val deleted = list[0] as List<String?>
      val inserted = list[1] as List<String?>
      val newToken = ApiHistoryToken.fromList(list[2] as List<Any?>)
      val updated = list[3] as List<String?>
      return ApiChanges(deleted, inserted, newToken, updated)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      deleted,
      inserted,
      newToken.toList(),
      updated,
    )
  }
}

@Suppress("UNCHECKED_CAST")
private object FinanceKitApiCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiAccount.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiAccountBalance.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiAccountCreditInformation.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiAssetAccount.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiBalance.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiChanges.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiCurrencyAmount.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiCurrencyAmount.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiHistoryToken.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiLiabilityAccount.fromList(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiPredicate.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiQueryParams.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiSortDescriptor.fromList(it)
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ApiTransaction.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is ApiAccount -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is ApiAccountBalance -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is ApiAccountCreditInformation -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is ApiAssetAccount -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is ApiBalance -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is ApiChanges -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is ApiCurrencyAmount -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is ApiCurrencyAmount -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is ApiHistoryToken -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is ApiLiabilityAccount -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is ApiPredicate -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is ApiQueryParams -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is ApiSortDescriptor -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      is ApiTransaction -> {
        stream.write(141)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface FinanceKitApi {
  fun isDataAvailable(type: ApiDataType): Boolean
  fun authorizationStatus(callback: (Result<ApiAuthorizationStatus>) -> Unit)
  fun requestAuthorization(callback: (Result<ApiAuthorizationStatus>) -> Unit)
  fun accounts(query: ApiQueryParams, callback: (Result<List<ApiAccount>>) -> Unit)
  fun accountBalances(query: ApiQueryParams, callback: (Result<List<ApiAccountBalance>>) -> Unit)
  fun transactions(query: ApiQueryParams, callback: (Result<List<ApiTransaction>>) -> Unit)
  fun test(): List<ApiChanges>

  companion object {
    /** The codec used by FinanceKitApi. */
    val codec: MessageCodec<Any?> by lazy {
      FinanceKitApiCodec
    }
    /** Sets up an instance of `FinanceKitApi` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: FinanceKitApi?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_financekit.FinanceKitApi.isDataAvailable", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val typeArg = ApiDataType.ofRaw(args[0] as Int)!!
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isDataAvailable(typeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_financekit.FinanceKitApi.authorizationStatus", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.authorizationStatus() { result: Result<ApiAuthorizationStatus> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data!!.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_financekit.FinanceKitApi.requestAuthorization", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.requestAuthorization() { result: Result<ApiAuthorizationStatus> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data!!.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_financekit.FinanceKitApi.accounts", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val queryArg = args[0] as ApiQueryParams
            api.accounts(queryArg) { result: Result<List<ApiAccount>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_financekit.FinanceKitApi.accountBalances", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val queryArg = args[0] as ApiQueryParams
            api.accountBalances(queryArg) { result: Result<List<ApiAccountBalance>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_financekit.FinanceKitApi.transactions", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val queryArg = args[0] as ApiQueryParams
            api.transactions(queryArg) { result: Result<List<ApiTransaction>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_financekit.FinanceKitApi.test", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.test())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
